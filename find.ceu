/*{-{*/

@define(FIND_LINS, LIST_LINS);
@define(FIND_COLS, 10);

class FindL with
    event void   go;
    var   UIGrid grid;
    var   int    n;
do
    var _SDL_Texture* tex_add := _IMG_LoadTexture(global:ren, "imgs/add.png");

    grid.spc_x = LIST_SPCX;
    grid.spc_y = LIST_SPCY;

    // 1,2,3,4,5,..
    var u8[ LIST_LINS ] lay;
    loop lin, LIST_LINS do
        lay[lin] = lin+1;
    end
    grid.lay_lins = LIST_LINS;
    grid.lay_cols = 1;
    grid.lay := lay;            // TODO !!! depth diferentes?

    var UIDrawable*[LIST_LINS] draws;
    grid.it_n = LIST_LINS;
    grid.it_draws := draws;     // TODO !!! depth diferentes?
    loop lin, LIST_LINS do
        draws[lin] = null;
    end

    await/0 go;

    // add
    loop lin, FIND_LINS do
        if lin < this.n then
            var UITexDrawable* d;
            grid.it_draws[lin] = new UITexDrawable;
            d = <UITexDrawable*> grid.it_draws[lin];
            d:tex = tex_add;
        end
    end

    await FOREVER;

finally
    _SDL_DestroyTexture(tex_add);
end

class Find with
    event void   go;
    var   UIGrid grid;
    var  _char*  str;
do
    var int ref = _LUA_NOREF;

    // find res list
    var List res;

    // L1/L2
    var FindL l1, l2;

    grid.clr_bg? = 1;
    grid.clr_bg = global:clr_bg;
    var _SDL_Color clr_txt = global:clr_txt;
    grid.spc_x = LIST_SPCX;
    grid.spc_y = LIST_SPCY;

    var u8[ eval(FIND_LINS*FIND_COLS) ] lay;
    // list         l1, l2
    // 1,1,1,1,1,1,1,1,2,3
    // 1,1,1,1,1,1,1,1,2,3
    // ...
    loop lin, FIND_LINS do
        loop col, FIND_COLS-2 do
            lay[lin*FIND_COLS+col] = 1;
        end
        lay[lin*FIND_COLS+8] = 2;
        lay[lin*FIND_COLS+9] = 3;
    end
    grid.lay_lins = FIND_LINS;
    grid.lay_cols = FIND_COLS;
    grid.lay := lay;            // TODO !!! depth diferentes?

    var UIDrawable*[3] draws;
        draws[0] = res.drawable;
        draws[1] = &l1.grid;
        draws[2] = &l2.grid;
    grid.it_n = 3;
    grid.it_draws := draws;     // TODO !!! depth diferentes?

    await/0 go;

    // res = find(cards, str)
    var _lua_State* lua = global:lua;
    _lua_pushvalue(lua, 1);         // [ find ]
    _lua_pushvalue(lua, 2);         // [ find | cards ]
    _lua_pushstring(lua, str);      // [ find | cards | name ]
    _lua_call(lua, 2, 1);           // [ res ]
    var int n_res = _lua_objlen(lua, -1);
    ref = _luaL_ref(lua, _LUA_REGISTRYINDEX); // [ ]

    // list
        res.ref = ref;
        emit res.go;

    // l1, l2
        l1.n = n_res;
        l2.n = n_res;
        emit l1.go;
        emit l2.go;

    // add
    loop do
        var int* opt;
        var int l =     // L1 or L2
            par do
                opt = await l1.grid.ok_clicked;
                return global:ref_l1;
            with
                opt = await l2.grid.ok_clicked;
                return global:ref_l2;
            end;

        _lua_rawgeti(lua, _LUA_REGISTRYINDEX, ref); // [ res ]
        _lua_rawgeti(lua, -1, *opt);                // [ res | card ]

        if not _lua_isnil(lua,-1) then
            emit global:go_sound = global:snd_add;
            _lua_rawgeti(lua, _LUA_REGISTRYINDEX, l);
            var int n_l = _lua_objlen(lua, -1);
            _lua_pushvalue(lua, -2);                // [ res | card | l | card ]
            _lua_rawseti(lua, -2, n_l+1);           // [ res | card | l ]
            _lua_pop(lua, 1);                       // [ res | card ]
        end

        _lua_pop(lua, 2);                           // [ ]
    end
finally
    _luaL_unref(lua, _LUA_REGISTRYINDEX, ref);
end

/*}-}*/ dnl
